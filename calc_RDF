"""
ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®èª¬æ˜
1. è·é›¢ã®è¨ˆç®—ã¨ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®ä½œæˆ

def calculate_rdf(u, ag1, ag2, nbins=75, r_range=(0.0, 15.0)):
    ...

ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®åˆæœŸåŒ–:
rdf = np.zeros(nbins): RDFã‚’æ ¼ç´ã™ã‚‹é…åˆ—ã‚’åˆæœŸåŒ–ã€‚
bins: è·é›¢ã®åŒºé–“ã‚’å®šç¾©ã€‚
bin_centers: ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®ä¸­å¿ƒå€¤ã€‚


å…¨ãƒ•ãƒ¬ãƒ¼ãƒ ã§ãƒ«ãƒ¼ãƒ—:
for ts in u.trajectory:
    ...
å„ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã€ã‚°ãƒ«ãƒ¼ãƒ—Aã¨ã‚°ãƒ«ãƒ¼ãƒ—Bã®åŸå­é–“ã®è·é›¢ã‚’è¨ˆç®—ã€‚
mda.lib.distances.distance_arrayã‚’ä½¿ç”¨ã—ã¦ã€è·é›¢è¡Œåˆ—ã‚’è¨ˆç®—ã€‚
è·é›¢ã‚’ãƒ•ãƒ©ãƒƒãƒˆãª1æ¬¡å…ƒé…åˆ—ã«å¤‰æ›ã€‚


ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®æ›´æ–°:
hist, _ = np.histogram(distances, bins=bins)
rdf += hist
è¨ˆç®—ã—ãŸè·é›¢ã‚’ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã«é›†è¨ˆã€‚

2. RDFã®æ­£è¦åŒ–
# RDFã®æ­£è¦åŒ–
rdf = rdf / total_counts  # ãƒšã‚¢ã®ç·æ•°ã§å‰²ã‚‹

number_density = len(ag2) / avg_volume  # ç›¸æ‰‹ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°å¯†åº¦

shell_volumes = (4.0 / 3.0) * np.pi * (bins[1:]**3 - bins[:-1]**3)  # ã‚·ã‚§ãƒ«ã®ä½“ç©
ideal_gas = shell_volumes * number_density  # ç†æƒ³æ°—ä½“ã®ç²’å­æ•°

rdf = rdf / ideal_gas  # ç†æƒ³æ°—ä½“ã®åˆ†å¸ƒã§å‰²ã‚‹
rdf = rdf / n_frames  # ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã§å¹³å‡åŒ–
ãƒšã‚¢ã®ç·æ•°ã§æ­£è¦åŒ–:

RDFã‚’ãƒšã‚¢ã®ç·æ•°ã§å‰²ã‚‹ã“ã¨ã§ã€ç¢ºç‡å¯†åº¦ã«å¤‰æ›ã€‚
ç†æƒ³æ°—ä½“ã®åˆ†å¸ƒã§å‰²ã‚‹:

ã‚·ã‚§ãƒ«ã®ä½“ç©ã¨ç›¸æ‰‹ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°å¯†åº¦ã‚’ç”¨ã„ã¦ã€ç†æƒ³æ°—ä½“ã®ç²’å­æ•°ã‚’è¨ˆç®—ã€‚
RDFã‚’ç†æƒ³æ°—ä½“ã®åˆ†å¸ƒã§å‰²ã‚‹ã“ã¨ã§ã€æœ€çµ‚çš„ãªRDFã‚’å¾—ã‚‹ã€‚
ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã§å¹³å‡åŒ–:

å…¨ã¦ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§è¨ˆç®—ã—ãŸçµæœã‚’å¹³å‡åŒ–ã€‚
ä½¿ç”¨æ–¹æ³•
ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã¾ãŸã¯ã‚³ãƒãƒ³ãƒ‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å®Ÿè¡Œã—ã¾ã™ã€‚

bash
ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹
python rdf_manual.py -t topology.gro -d trajectory.dump -s1 "name O" -s2 "name H" --bins 100 --range 15.0 --output rdf_output.png
-t topology.gro: ãƒˆãƒãƒ­ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.groå½¢å¼ï¼‰ã€‚
-d trajectory.dump: ãƒˆãƒ©ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.dumpå½¢å¼ï¼‰ã€‚
-s1 "name O": ç¬¬1ã®åŸå­ã‚°ãƒ«ãƒ¼ãƒ—ã®é¸æŠï¼ˆä¾‹ï¼šåŸå­åãŒ'O'ã®åŸå­ï¼‰ã€‚
-s2 "name H": ç¬¬2ã®åŸå­ã‚°ãƒ«ãƒ¼ãƒ—ã®é¸æŠï¼ˆä¾‹ï¼šåŸå­åãŒ'H'ã®åŸå­ï¼‰ã€‚
--bins 100: RDFã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®ãƒ“ãƒ³æ•°ã‚’100ã«è¨­å®šã€‚
--range 15.0: RDFè¨ˆç®—ã®æœ€å¤§è·é›¢ã‚’15.0ã‚ªãƒ³ã‚°ã‚¹ãƒˆãƒ­ãƒ¼ãƒ ã«è¨­å®šã€‚
--output rdf_output.png: RDFãƒ—ãƒ­ãƒƒãƒˆã‚’rdf_output.pngã¨ã—ã¦ä¿å­˜ã€‚
è£œè¶³èª¬æ˜
1. ã‚·ã‚§ãƒ«ã®ä½“ç©ã®è¨ˆç®—
ã‚·ã‚§ãƒ«ã®ä½“ç©ã¯ã€çƒæ®»ã®ä½“ç©ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã§æ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚

  ã¯ãƒ“ãƒ³ã®å†…å´ã¨å¤–å´ã®åŠå¾„ã€‚
2. ç†æƒ³æ°—ä½“ã®æ•°å¯†åº¦
ç›¸æ‰‹ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—Bï¼‰ã®æ•°å¯†åº¦ã¯ã€å…¨ä½“ã®ä½“ç©ã«å¯¾ã™ã‚‹åŸå­æ•°ã§è¨ˆç®—ã—ã¾ã™ã€‚

  ã¯ã‚°ãƒ«ãƒ¼ãƒ—Bã®åŸå­æ•°ã€‚
ğ‘‰
V ã¯ç³»ã®ä½“ç©ã€‚
3. RDFã®æ­£è¦åŒ–ã®ç†ç”±
RDFã¯ã€ã‚ã‚‹è·é›¢ 
ğ‘Ÿ
r ã«ãŠã‘ã‚‹ç²’å­ã®å­˜åœ¨ç¢ºç‡ã‚’ç¤ºã™é–¢æ•°ã§ã‚ã‚Šã€ç†æƒ³æ°—ä½“ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã§ã€æ§‹é€ ã®ç‰¹å¾´ã‚’æ˜ã‚‰ã‹ã«ã—ã¾ã™ã€‚
æ³¨æ„äº‹é …
å‘¨æœŸå¢ƒç•Œæ¡ä»¶: è·é›¢ã®è¨ˆç®—æ™‚ã«å‘¨æœŸå¢ƒç•Œæ¡ä»¶ã‚’è€ƒæ…®ã—ã¦ã„ã¾ã™ã€‚ãƒœãƒƒã‚¯ã‚¹æƒ…å ±ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

è¨ˆç®—æ™‚é–“: ãƒˆãƒ©ã‚¸ã‚§ã‚¯ãƒˆãƒªãŒå¤§ãã„å ´åˆã€è¨ˆç®—æ™‚é–“ãŒé•·ããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãã®å ´åˆã€ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é–“å¼•ãã‹ã€åŸå­ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å°ã•ãã™ã‚‹ã“ã¨ã§å¯¾å¿œã§ãã¾ã™ã€‚

å˜ä½ç³»: ãƒˆãƒãƒ­ã‚¸ãƒ¼ã¨ãƒˆãƒ©ã‚¸ã‚§ã‚¯ãƒˆãƒªã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒåŒã˜å˜ä½ç³»ï¼ˆé€šå¸¸ã¯ã‚ªãƒ³ã‚°ã‚¹ãƒˆãƒ­ãƒ¼ãƒ ï¼‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚


"""
import MDAnalysis as mda
import numpy as np
import matplotlib.pyplot as plt
import argparse

def calculate_rdf(u, ag1, ag2, nbins=75, r_range=(0.0, 15.0)):
    # RDFã‚’æ ¼ç´ã™ã‚‹é…åˆ—ã‚’åˆæœŸåŒ–
    rdf = np.zeros(nbins)
    rmin, rmax = r_range
    bins = np.linspace(rmin, rmax, nbins + 1)
    bin_centers = 0.5 * (bins[:-1] + bins[1:])
    dr = bins[1] - bins[0]

    # å…¨ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
    n_frames = len(u.trajectory)
    print(f"Total number of frames: {n_frames}")

    # ç³»å…¨ä½“ã®ä½“ç©ï¼ˆå¹³å‡å€¤ã‚’ä½¿ç”¨ï¼‰
    volumes = []
    for ts in u.trajectory:
        volumes.append(ts.volume)
    avg_volume = np.mean(volumes)

    # ç·è·é›¢æ•°
    total_counts = 0

    # å„ãƒ•ãƒ¬ãƒ¼ãƒ ã§è·é›¢ã‚’è¨ˆç®—ã—ã€ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’æ›´æ–°
    for ts in u.trajectory:
        # è·é›¢è¡Œåˆ—ã®è¨ˆç®—ï¼ˆå‘¨æœŸå¢ƒç•Œæ¡ä»¶ã‚’è€ƒæ…®ï¼‰
        distances = mda.lib.distances.distance_array(ag1.positions, ag2.positions, box=ts.dimensions)
        distances = distances.flatten()

        # ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®æ›´æ–°
        hist, _ = np.histogram(distances, bins=bins)
        rdf += hist

        # ç·è·é›¢æ•°ã®æ›´æ–°
        total_counts += len(distances)

    # RDFã®æ­£è¦åŒ–
    # ãƒšã‚¢ã®æ•°ã§å‰²ã‚‹
    rdf = rdf / total_counts

    # ç†æƒ³æ°—ä½“ã®åˆ†å¸ƒã§å‰²ã‚‹ï¼ˆä½“ç©è¦ç´ ã§å‰²ã‚‹ï¼‰
    number_density = len(ag2) / avg_volume  # ç›¸æ‰‹ã‚°ãƒ«ãƒ¼ãƒ—ã®æ•°å¯†åº¦
    shell_volumes = (4.0 / 3.0) * np.pi * (bins[1:]**3 - bins[:-1]**3)
    ideal_gas = shell_volumes * number_density

    rdf = rdf / ideal_gas
    rdf = rdf / n_frames  # ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã§å¹³å‡åŒ–

    return bin_centers, rdf

def main():
    parser = argparse.ArgumentParser(description='Calculate RDF without using InterRDF.')
    parser.add_argument('-t', '--topology', required=True, help='Topology file (.gro)')
    parser.add_argument('-d', '--trajectory', required=True, help='Trajectory file (.dump)')
    parser.add_argument('-s1', '--selection1', required=True, help='Atom selection for group 1 (e.g., "name O")')
    parser.add_argument('-s2', '--selection2', required=True, help='Atom selection for group 2 (e.g., "name H")')
    parser.add_argument('--bins', type=int, default=75, help='Number of bins for the RDF histogram')
    parser.add_argument('--range', type=float, default=15.0, help='Maximum distance for the RDF calculation (Angstrom)')
    parser.add_argument('--output', default='rdf_output.png', help='Filename for the output RDF plot')

    args = parser.parse_args()

    # Universeã®ä½œæˆ
    u = mda.Universe(args.topology, args.trajectory, topology_format='GRO', format='LAMMPSDUMP')

    # åŸå­ã‚°ãƒ«ãƒ¼ãƒ—ã®é¸æŠ
    ag1 = u.select_atoms(args.selection1)
    ag2 = u.select_atoms(args.selection2)

    print(f"Selected {len(ag1)} atoms for group 1 and {len(ag2)} atoms for group 2.")

    if len(ag1) == 0 or len(ag2) == 0:
        print("Error: One of the selection groups is empty.")
        return

    # RDFã®è¨ˆç®—
    distances, rdf = calculate_rdf(u, ag1, ag2, nbins=args.bins, r_range=(0.0, args.range))

    # RDFã®ãƒ—ãƒ­ãƒƒãƒˆ
    plt.figure()
    plt.plot(distances, rdf)
    plt.xlabel('Distance (Ã…)')
    plt.ylabel('g(r)')
    plt.title('Radial Distribution Function')
    plt.grid(True)
    plt.savefig(args.output)
    plt.show()

    print(f"RDF plot saved as {args.output}")

if __name__ == '__main__':
    main()
